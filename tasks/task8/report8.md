# Задание 8 — Шаги 4–5: Формальные спецификации АТД для консольной игры «Три‑в‑ряд»

Область: минимально необходимое по ТЗ — поле 8×8, фишки A–E, ввод ходов (своп соседних), поиск и удаление совпадений (≥3 в линию), падение, каскады, подсчёт очков, окончание при отсутствии ходов. Терминология согласована и не противоречит ранее выполненным заданиям `tasks/task1..task7`.

## Кластеры (логические группы)

- Board: представление доски и базовые операции над ячейками/фишками
- Rules: правила валидности ходов и поиск совпадений
- Mechanics: удаление, падение, каскады
- Scoring: подсчёт очков и трекинг комбо/каскадов
- Random: поставщик случайностей (для генерации и наполнения)
- Control: координация хода игры и состояний (без I/O)
- IO: консольный порт ввода/вывода (адаптер), не влияет на доменную логику

## Перечень АТД и иерархий

- TileKind: множество допустимых видов фишек {A, B, C, D, E}
- Tile: фишка определённого `TileKind`
- Cell: адресуемая позиция доски с координатами (row, col)
- Board (абстрактный класс поведения): интерфейс immutable‑запросов и базовых проверок
- MutableBoard <: Board: конкретизация с изменяемыми операциями
- SwapValidator: проверка допустимости свопа соседних ячеек
- MoveGenerator: генератор всех допустимых ходов на доске
- MatchFinder: поиск всех совпадений (горизонт/вертикаль, длина ≥3)
- MatchResolver: применение удаления совпадений к доске
- GravityEngine: падение фишек и заполнение пустот новыми
- ScoreManager: расчёт очков за совпадения и каскады
- ComboTracker: счётчик/коэффициент каскада текущего хода
- RandomProvider (интерфейс): источник случайных значений/фишек
- RandomProviderDefault <: RandomProvider: стандартная реализация
- GameState: агрегирует текущую доску, счёт, состояние партии
- GameController: координация шага игры (своп → резолв → каскады → завершение)
- ConsoleIO: адаптер ввода координат и вывода доски/счёта (порт)

Далее указываются спецификации в терминах команд (изменяют состояние), запросов (не изменяют), пред-/постусловий и инвариантов.

---

## TileKind

- Запросы
  - all(): множество допустимых значений {A,B,C,D,E} — (запрос) вернуть набор допустимых видов
- Инварианты
  - all() неизменно в ходе партии

## Tile

- Запросы
  - kind() → TileKind — (запрос) получить вид фишки
- Инварианты
  - kind() ∈ TileKind.all()

## Cell

- Запросы
  - row() → int — (запрос) получить индекс строки
  - col() → int — (запрос) получить индекс столбца
- Инварианты
  - 0 ≤ row() < 8, 0 ≤ col() < 8

## Board (абстрактный класс поведения)

- Запросы
  - width() → 8 — (запрос) ширина доски
  - height() → 8 — (запрос) высота доски
  - tile_at(cell: Cell) → Tile | None — (запрос) получить фишку в ячейке
  - is_inside(cell: Cell) → bool — (запрос) проверить, что ячейка в пределах доски
  - enumerate_cells() → Iterable[Cell] — (запрос) перечислить все ячейки доски
  - clone() → Board — (запрос) создать копию доски
- Инварианты
  - Для всех c ∈ enumerate_cells(): is_inside(c) = true
  - Для всех c внутри: tile_at(c) = None или tile_at(c).kind ∈ TileKind
  - Размеры фиксированы: width()=8, height()=8

## MutableBoard <: Board

- Команды
  - set_tile(cell: Cell, tile: Tile | None) — (команда) установить фишку в ячейку
    - Пред: is_inside(cell)
    - Пост: tile_at(cell) = tile; прочие клетки неизменны
  - swap(a: Cell, b: Cell) — (команда) обменять содержимое двух соседних ячеек
    - Пред: is_inside(a) ∧ is_inside(b) ∧ соседние(a,b)
    - Пост: содержимое a и b обменяно местами
  - fill_empty(random: RandomProvider) — (команда) заполнить пустые ячейки новыми фишками
    - Пред: для всех c с tile_at(c)=None — допустимо генерировать TileKind
    - Пост: пустые клетки заполнены фишками допустимых видов; непрерывные инварианты доски сохранены
- Инварианты
  - Нет «посторонних» значений: каждая фишка допустима

## SwapValidator

- Запросы
  - is_adjacent(a: Cell, b: Cell) → bool — (запрос) проверка соседства ячеек по стороне
  - is_swap_creating_match(board: Board, a: Cell, b: Cell) → bool — (запрос) даст ли своп хотя бы одно совпадение
    - Пред: Board.is_inside(a) ∧ Board.is_inside(b) ∧ is_adjacent(a,b)
    - Пост: true, если гипотетический обмен создаёт ≥1 новую линию длиной ≥3

## MoveGenerator

- Запросы
  - generate_legal_moves(board: Board) → Iterable[(Cell, Cell)] — (запрос) перечислить все валидные свопы
    - Пост: для каждой пары (a,b): соседние(a,b) ∧ SwapValidator.is_swap_creating_match(...)=true

## MatchFinder

- Запросы
  - find_matches(board: Board) → Set[Set[Cell]] — (запрос) найти все группы совпадений на доске
    - Пост: множество групп ячеек, каждая группа — максимальная непрерывная горизонтальная или вертикальная линия одного TileKind длиной ≥3; группы попарно непересекаются

## MatchResolver

- Команды
  - remove_matches(board: MutableBoard, matches: Set[Set[Cell]]) → int removed_count — (команда) удалить совпадения, вернуть число удалённых
    - Пред: все ячейки в matches внутри доски, группы валидны по MatchFinder
    - Пост: tile_at(c)=None для всех c в matches; возвращает количество удалённых фишек

## GravityEngine

- Команды
  - apply_gravity(board: MutableBoard) — (команда) «уронить» фишки вниз в каждом столбце
    - Пост: для каждого столбца все непустые фишки «сжаты» книзу, над ними могут быть только None; относительный порядок падения в столбце сохраняется
  - refill(board: MutableBoard, random: RandomProvider) — (команда) дозаполнить пустоты новыми фишками
    - Пред: возможна генерация новых фишек
    - Пост: все None заполнены допустимыми Tile согласно RandomProvider

## ScoreManager

- Запросы
  - score_for_removed(removed_count: int, cascade_index: int) → int — (запрос) расчёт очков за волну с учётом каскада
    - Пост: монотонно неубывающая по removed_count и увеличенная множителем каскада (cascade_index ≥0)
- Команды
  - add_points(state: GameState, points: int) — (команда) увеличить счёт на заданное число очков
    - Пост: state.score увеличен на points

## ComboTracker

- Команды
  - reset() — (команда) сбросить индекс каскада к 0
    - Пост: текущий индекс каскада = 0
  - increment() — (команда) увеличить индекс каскада на 1
    - Пост: текущий индекс каскада = предыдущее + 1
- Запросы
  - current_index() → int — (запрос) получить текущий индекс каскада

## RandomProvider (интерфейс) и RandomProviderDefault

- Запросы
  - next_tile_kind() → TileKind — (запрос) получить следующий вид фишки по источнику случайности
    - Пост: результат ∈ TileKind
- Инварианты
  - Не создаёт недопустимых значений

## GameState

- Состав
  - board: Board — текущая доска
  - score: int — текущий счёт игрока
  - moves_available: bool — флаг наличия валидных ходов
- Инварианты
  - board инварианты соблюдены; score ≥ 0

## GameController (без I/O)

- Команды (атомика шага)
  - perform_move(state: GameState, a: Cell, b: Cell, services: {SwapValidator, MatchFinder, MatchResolver, GravityEngine, ScoreManager, ComboTracker, RandomProvider}) → bool applied — (команда) выполнить один ход со всеми каскадами
    - Пред: SwapValidator.is_adjacent(a,b); SwapValidator.is_swap_creating_match(state.board,a,b)=true
    - Пост (если applied=true):
      1) выполнен своп на копии доски; 
      2) найдены матчи; 
      3) удалены фишки; 
      4) начислены очки за первую волну; 
      5) применена гравитация и дозаполнение; 
      6) повторять 2–5, пока возникают новые матчи, наращивая индекс каскада; 
      7) state.board заменена на финальную доску; score увеличен суммарно; 
      8) возвращено true.
    - Пост (если applied=false): state неизменён
- Команды (обновление статуса партии)
  - update_moves_available(state: GameState, generator: MoveGenerator) — (команда) пересчитать флаг доступности ходов
    - Пост: state.moves_available ↔ generator.generate_legal_moves(state.board) не пуст

## ConsoleIO (порт)

- Запросы/Команды (примерные)
  - read_move() → (Cell, Cell) — (запрос) получить ход пользователя из консоли
  - print_board(board: Board) — (команда) вывести доску в консоль
  - print_score(score: int) — (команда) вывести текущий счёт
  - print_game_over() — (команда) вывести сообщение об окончании игры
- Требования
  - Не изменяет доменную логику; ошибки ввода обрабатываются на уровне адаптера

---

## Глобальные инварианты и ограничения

- Доска всегда 8×8; координаты в диапазоне [0..7]
- Допустимые фишки: только TileKind ∈ {A,B,C,D,E}
- Начальная генерация доски (вне рамок данного документа, но в реализации): предпочтительно без стартовых совпадений (если реализуется — обеспечить find_matches(board)=∅)
- После полного завершения `perform_move` на доске отсутствуют совпадения, иначе каскад продолжается
- Порядок каскадов: каждая новая волна — новая итерация поиска/удаления/падения/рефила с увеличением индекса

## Ошибочные ситуации и реакции

- Выход за границы доски → ошибка предусловия
- Своп не соседних клеток → ошибка предусловия
- Своп, не создающий совпадения → команда `perform_move` возвращает false без изменений состояния
- Несогласованные группы в `remove_matches` (невалидные координаты/пересечения) → ошибка предусловия

## Интерфейсы между кластерами (слабые связи)

- Control → Rules/Mechanics/Scoring/Random: через минимальные интерфейсы сервисов; `GameController` ничего не знает о деталях реализации
- Mechanics опирается только на интерфейс `Board`/`MutableBoard` и `RandomProvider`
- IO видит только запросы `Board` и примитивы `score`, не меняет домен

## Минимальные сценарии использования (без I/O)

1) Валидный ход: проверка валидности → `perform_move` → каскады → обновление `moves_available`
2) Невалидный ход: проверка валидности → `perform_move` → false → состояние без изменений
3) Завершение игры: после хода обновление `moves_available=false` → игра окончена

---



